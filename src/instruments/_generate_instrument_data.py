"""
Generates the instrument data model containing the data from the JSON files in this package.
"""

import base64
import json
import os


_OUTPUT_FILENAME = '../models/instrument_data.py'
_MAX_LINE_LENGTH = 100
_INDENT_WIDTH = 4


def generate_instrument_data():
    names = []
    with open(_OUTPUT_FILENAME, 'w') as fp_model:
        fp_model.write('"""\n')
        fp_model.write('This file is automatically generated by the instruments/_generate_instrument_data.py script.\n')
        fp_model.write('"""\n\n')
        fp_model.write('import base64\n')
        fp_model.write('import json\n\n\n')
        fp_model.write('class InstrumentData(object):\n')

        for item in os.listdir('.'):
            if item.endswith('.json'):
                name = 'instrument_{}'.format(os.path.splitext(item)[0])
                assert name not in names, 'The name {} already exists'.format(name)
                names.append(name)
                json_data = json.load(open(item, 'r'))
                content = base64.b64encode(json.dumps(json_data).encode('latin'))
                fp_model.write('\n    {} = base64.b64decode(\n'.format(name))
                max_data_length = _MAX_LINE_LENGTH - _INDENT_WIDTH
                indent = _INDENT_WIDTH * 2
                while len(content) > max_data_length:
                    fp_model.write('{}{}\n'.format(' ' * indent, content[:max_data_length]))
                    content = content[max_data_length:]
                if len(content) > 0:
                    fp_model.write('{}{}\n'.format(' ' * indent, content))
                indent -= 4
                fp_model.write('{})\n'.format(' ' * indent))

        fp_model.write('\n    @classmethod\n')
        fp_model.write('    def get_list_of_instrument_names(cls):\n')
        fp_model.write('        attributes = list(filter(lambda x: x.startswith(\'instrument_\'), vars(cls).keys()))\n')
        fp_model.write('        names = map(lambda x: json.loads(getattr(cls, x))[\'name\'], attributes)\n')
        fp_model.write('        return sorted(list(names))\n')

        fp_model.write('\n    @classmethod\n')
        fp_model.write('    def get_instrument_data_by_name(cls, instrument_name):\n')
        fp_model.write('        attributes = list(filter(lambda x: x.startswith(\'instrument_\'), vars(cls).keys()))\n')
        fp_model.write('        matches = list(filter(lambda x: json.loads(getattr(cls, x))[\'name\'] == '
                       'instrument_name, attributes))\n')
        fp_model.write('        if len(matches) == 1:\n')
        fp_model.write('            return getattr(cls, matches[0])\n')
        fp_model.write('        return None\n')

        fp_model.write("\n\nif __name__ == '__main__':\n\n")
        fp_model.write('    for name in InstrumentData.get_list_of_instrument_names():\n')
        fp_model.write('        print(json.loads(InstrumentData.get_instrument_data_by_name(name)))\n')


if __name__ == '__main__':

    generate_instrument_data()
